<!DOCTYPE html>
<html>
<head>
<title>chemin d'une requete du client a l utilisation de l'application.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>D'accord, je vais reprendre la description de la chronologie de la requête en intégrant les étapes de hachage et de routage. Voici une description détaillée de la requête dans une application frontend-centrée déployée sur AWS avec Docker, utilisant Nginx, Express.js, et Node.js, où chaque utilisateur a accès à une application spécifique parmi plusieurs disponibles, et les paramètres spécifiques à chaque utilisateur sont chargés dynamiquement.</p>
<h3 id="structure-de-lapplication">Structure de l'Application</h3>
<ol>
<li>
<p><strong>Frontend (React.js)</strong> :</p>
<ul>
<li>Application React.js déployée dans un conteneur Docker.</li>
<li>Code de base identique pour tous les utilisateurs.</li>
<li>Composants et modules chargés dynamiquement en fonction des autorisations de l'utilisateur.</li>
</ul>
</li>
<li>
<p><strong>Backend (Express.js/Node.js)</strong> :</p>
<ul>
<li>Serveur Express.js/Node.js déployé dans un conteneur Docker.</li>
<li>Gère l'authentification, les autorisations, et les requêtes API.</li>
</ul>
</li>
<li>
<p><strong>Nginx</strong> :</p>
<ul>
<li>Serveur Nginx déployé dans un conteneur Docker, agissant comme reverse proxy.</li>
</ul>
</li>
<li>
<p><strong>Base de Données</strong> :</p>
<ul>
<li>Base de données (par exemple, MongoDB) déployée dans un conteneur Docker.</li>
<li>Stocke les informations d'identification des utilisateurs, les autorisations, et les paramètres spécifiques à chaque utilisateur.</li>
</ul>
</li>
</ol>
<h3 id="chronologie-de-la-requ%C3%AAte">Chronologie de la Requête</h3>
<ol>
<li>
<p><strong>Connexion du Client</strong> :</p>
<ul>
<li>Le client ouvre un navigateur web et entre l'URL du nom de domaine lié à l'application (par exemple, <code>https://www.example.com</code>).</li>
</ul>
</li>
<li>
<p><strong>Résolution DNS</strong> :</p>
<ul>
<li>Le nom de domaine est résolu en une adresse IP par le serveur DNS.</li>
<li>Le navigateur envoie une requête HTTP/HTTPS à l'adresse IP du serveur AWS.</li>
</ul>
</li>
<li>
<p><strong>Nginx (Reverse Proxy)</strong> :</p>
<ul>
<li>Nginx écoute les requêtes HTTP/HTTPS sur le port 80/443.</li>
<li>Nginx reçoit la requête et redirige les requêtes vers le frontend ou le backend en fonction de l'URI.</li>
</ul>
</li>
<li>
<p><strong>Requête Initiale (Frontend)</strong> :</p>
<ul>
<li>La requête initiale est une requête GET pour charger l'application React.js.</li>
<li>Nginx redirige cette requête vers le serveur frontend (React.js) :<pre class="hljs"><code><div><span class="hljs-attribute">location</span> / {
    <span class="hljs-attribute">proxy_pass</span> http://frontend:3000;
    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;
}
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Chargement de l'Application React.js</strong> :</p>
<ul>
<li>Le serveur frontend (React.js) répond avec les fichiers HTML, CSS, et JavaScript nécessaires pour charger l'application.</li>
<li>Le navigateur du client télécharge et exécute ces fichiers, affichant l'interface utilisateur de l'application.</li>
</ul>
</li>
<li>
<p><strong>Affichage de la Page de Connexion</strong> :</p>
<ul>
<li>L'application React.js détecte que l'utilisateur n'est pas authentifié et affiche la page de connexion.</li>
</ul>
</li>
<li>
<p><strong>Soumission du Formulaire de Connexion</strong> :</p>
<ul>
<li>L'utilisateur entre ses informations d'identification (par exemple, nom d'utilisateur et mot de passe) et soumet le formulaire de connexion.</li>
<li>Une requête POST est envoyée au serveur backend pour authentification :<pre class="hljs"><code><div>axios.post(<span class="hljs-string">'/api/login'</span>, { username, password })
    .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
        <span class="hljs-comment">// Gérer la réponse de connexion</span>
    })
    .catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
        <span class="hljs-comment">// Gérer les erreurs de connexion</span>
    });
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Nginx (Redirection vers le Backend)</strong> :</p>
<ul>
<li>Nginx reçoit la requête POST et la redirige vers le serveur backend (Express.js) :<pre class="hljs"><code><div><span class="hljs-attribute">location</span> /api {
    <span class="hljs-attribute">proxy_pass</span> http://backend:5000;
    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;
}
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Authentification (Express.js)</strong> :</p>
<ul>
<li>Le serveur backend (Express.js) reçoit la requête POST et traite les informations d'identification.</li>
<li>Le serveur vérifie les informations d'identification contre la base de données (par exemple, MongoDB).</li>
<li>Les mots de passe sont hachés avant d'être stockés dans la base de données pour des raisons de sécurité.</li>
<li>Si les informations d'identification sont correctes, le serveur génère un token JWT (JSON Web Token) et le renvoie au client.</li>
</ul>
</li>
<li>
<p><strong>Réponse de Connexion</strong> :</p>
<ul>
<li>Le serveur backend envoie une réponse avec le token JWT :<pre class="hljs"><code><div>res.json({ token });
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Stockage du Token JWT</strong> :</p>
<ul>
<li>Le client stocke le token JWT dans le stockage local (LocalStorage) ou dans un cookie sécurisé.</li>
</ul>
</li>
<li>
<p><strong>Accès à l'Application</strong> :</p>
<ul>
<li>Le client inclut le token JWT dans les en-têtes des requêtes suivantes pour accéder aux ressources protégées :<pre class="hljs"><code><div>axios.get(<span class="hljs-string">'/api/user-applications'</span>, {
    <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    }
})
.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-comment">// Gérer la réponse des applications disponibles</span>
})
.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-comment">// Gérer les erreurs d'accès</span>
});
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Nginx (Redirection vers le Backend)</strong> :</p>
<ul>
<li>Nginx reçoit les requêtes avec le token JWT et les redirige vers le serveur backend (Express.js).</li>
</ul>
</li>
<li>
<p><strong>Vérification du Token JWT (Express.js)</strong> :</p>
<ul>
<li>Le serveur backend (Express.js) vérifie le token JWT pour s'assurer qu'il est valide et non expiré.</li>
<li>Si le token est valide, le serveur traite la requête et renvoie les données demandées.</li>
</ul>
</li>
<li>
<p><strong>Réponse des Applications Disponibles</strong> :</p>
<ul>
<li>Le serveur backend envoie une réponse avec la liste des applications disponibles pour l'utilisateur.</li>
<li>Le client reçoit les données et affiche la liste des applications dans l'application React.js.</li>
</ul>
</li>
<li>
<p><strong>Sélection d'une Application</strong> :</p>
<ul>
<li>L'utilisateur sélectionne une application parmi celles disponibles.</li>
<li>Une requête GET est envoyée au serveur backend pour charger les paramètres et les projets de l'utilisateur pour l'application sélectionnée :<pre class="hljs"><code><div>axios.get(<span class="hljs-string">`/api/user-applications/<span class="hljs-subst">${applicationId}</span>/params`</span>, {
    <span class="hljs-attr">headers</span>: {
        <span class="hljs-string">'Authorization'</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">${token}</span>`</span>
    }
})
.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> {
    <span class="hljs-comment">// Gérer la réponse des projets disponibles</span>
})
.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-comment">// Gérer les erreurs d'accès</span>
});
</div></code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Chargement des Paramètres et Projets</strong> :</p>
<ul>
<li>Le serveur backend récupère les paramètres et les projets de l'utilisateur depuis la base de données et le dossier personnel de l'utilisateur.</li>
<li>Le serveur backend envoie une réponse avec les paramètres et les projets de l'utilisateur.</li>
</ul>
</li>
<li>
<p><strong>Affichage de l'Application Personnalisée</strong> :</p>
<ul>
<li>Le client reçoit les données et affiche l'application personnalisée avec les paramètres et les projets de l'utilisateur.</li>
<li>L'utilisateur peut maintenant travailler sur les différentes versions de l'application en fonction du projet sélectionné.</li>
</ul>
</li>
</ol>
<h3 id="hachage-et-routage">Hachage et Routage</h3>
<ul>
<li>
<p><strong>Hachage</strong> :</p>
<ul>
<li>Les mots de passe des utilisateurs sont hachés avant d'être stockés dans la base de données pour des raisons de sécurité.</li>
<li>Lors de l'authentification, le mot de passe fourni par l'utilisateur est haché et comparé au hachage stocké dans la base de données.</li>
</ul>
</li>
<li>
<p><strong>Routage</strong> :</p>
<ul>
<li>Nginx agit comme un reverse proxy et redirige les requêtes vers les serveurs frontend et backend appropriés en fonction de l'URI.</li>
<li>Express.js gère le routage des requêtes API et les redirige vers les contrôleurs appropriés pour traitement.</li>
</ul>
</li>
</ul>
<h3 id="exemple-de-code-pour-le-hachage-des-mots-de-passe">Exemple de Code pour le Hachage des Mots de Passe</h3>
<p><strong>controllers/auth.js</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> bcrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bcrypt'</span>);
<span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsonwebtoken'</span>);
<span class="hljs-keyword">const</span> User = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../models/User'</span>);

<span class="hljs-keyword">const</span> login = <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { username, password } = req.body;
 

 <span class="hljs-keyword">const</span>

 user = <span class="hljs-keyword">await</span> User.findOne({ username });
  <span class="hljs-keyword">if</span> (!user) {
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).json({ <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid credentials'</span> });
  }

  <span class="hljs-keyword">const</span> isMatch = <span class="hljs-keyword">await</span> bcrypt.compare(password, user.password);
  <span class="hljs-keyword">if</span> (!isMatch) {
    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">401</span>).json({ <span class="hljs-attr">message</span>: <span class="hljs-string">'Invalid credentials'</span> });
  }

  <span class="hljs-keyword">const</span> token = jwt.sign({ <span class="hljs-attr">id</span>: user._id, <span class="hljs-attr">username</span>: user

.username

 }, <span class="hljs-string">'secret_key'</span>, { <span class="hljs-attr">expiresIn</span>: <span class="hljs-string">'1h'</span> });
  res.json({ token });
};

<span class="hljs-built_in">module</span>.exports = { login };
</div></code></pre>
<p><strong>models/User.js</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> bcrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">'bcrypt'</span>);

<span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> mongoose.Schema({
  <span class="hljs-attr">username</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">password</span>: { <span class="hljs-attr">type</span>: <span class="hljs-built_in">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
});

userSchema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isModified(<span class="hljs-string">'password'</span>)) {
    <span class="hljs-keyword">return</span> next();
  }
  <span class="hljs-keyword">const</span> salt = <span class="hljs-keyword">await</span> bcrypt.genSalt(<span class="hljs-number">10</span>);
  <span class="hljs-keyword">this</span>.password = <span class="hljs-keyword">await</span> bcrypt.hash(<span class="hljs-keyword">this</span>.password, salt);
  next();
});

<span class="hljs-keyword">const</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);
<span class="hljs-built_in">module</span>.exports = User;
</div></code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>Dans cette architecture, Nginx agit comme un reverse proxy qui redirige les requêtes HTTP/HTTPS vers les serveurs frontend et backend appropriés. L'application React.js gère l'interface utilisateur et les interactions avec l'utilisateur, tandis que le serveur backend (Express.js) gère l'authentification, les requêtes API, et la gestion des paramètres et des projets de l'utilisateur. Le hachage des mots de passe est effectué avant de les stocker dans la base de données pour des raisons de sécurité. Le routage des requêtes est géré par Nginx et Express.js pour assurer une expérience utilisateur fluide et sécurisée, tout en offrant une application personnalisée en fonction des projets de l'utilisateur.</p>
<p>Similar code found with 1 license type</p>

</body>
</html>
